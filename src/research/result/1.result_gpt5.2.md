**Таблица отчёта о покрытии требований**

| Requirement | Coverage score | Linked tests | Confidence score | Evidence |
|---|---|---|---|---|
| req_015: Интеграция с CRM — «Сервер должен интегрироваться с внешним CRM‑решением.» | none | — | high (0.85) | В предоставленных данных нет тестов/фрагментов, которые явно проверяют интеграцию с внешним CRM (нет упоминаний CRM, протоколов/эндпоинтов, обмена данными). **Требование некачественное**: высокая неоднозначность и неполнота (не задано, *что именно* означает “интегрироваться”: API, события, сущности, авторизация, сценарии). |
| req_013: Эффективность — «Сервер должен быть эффективным.» | none | — | medium (0.65) | Есть “nearTests” с одинаковым score ~0.566, но их `mainIntent` указан как `"."` без содержания, поэтому **нет прямого доказательства**, что они проверяют эффективность (метрики, SLA, нагрузку, время ответа, потребление ресурсов). **Требование некачественное**: высокая неоднозначность (не определены метрики эффективности и критерии приемки). |
| req_014: Безопасность — «MCP‑Nest должен быть безопасным.» | partial | test-3: Reject unauthorized access attempts when credentials are invalid (test/mcp/server.test.ts:72–85) | medium (0.7) | test-3 явно проверяет **один аспект безопасности**: отклонение неавторизованного доступа при неверных учётных данных (“Reject unauthorized access…”, “secure protected resources…”, “Connection rejection”). Но требование “безопасным” слишком широкое и не покрывается полностью (нет явных проверок шифрования, ролей/прав, защиты от атак, audit/logging и т.п.). **Требование некачественное**: высокая неоднозначность (не определены конкретные свойства безопасности). |
| req_011: UI на React — «Сервер должен иметь графический интерфейс пользователя, написанный на React.» | none | — | high (0.85) | В данных нет тестов, которые явно проверяют наличие GUI и/или что он реализован именно на React (нет e2e UI, проверок сборки фронтенда, зависимостей, артефактов). |
| req_004: Авто‑обнаружение и регистрация декораторами — «MCP‑Nest должен автоматически обнаруживать и регистрировать инструменты, ресурсы и подсказки, помеченные соответствующими декораторами.» | none | — | medium (0.6) | Указанные nearTests проверяют **листинг** (“List available tools…”, “List resources and templates…”) но в их формулировках **нет явной проверки ключевого бизнес-намерения**: “автоматически обнаруживать” и “помеченные декораторами” (нет утверждений вида “при добавлении класса с @Tool/@Resource он автоматически появляется в реестре”). Также нет тестов про prompts. Семантическая близость не является доказательством покрытия. |
| req_009: Resource Templates — «Система должна позволять определять динамические ресурсы с параметризуемыми URI (Resource Templates).» | good | test-3-uuid: Retrieve dynamic resource content with parameterized input (test/mcp.e2e-spec.ts:76–85); test-4-uuid: Retrieve dynamic resource content with multiple path parameters (test/mcp.e2e-spec.ts:86–95) | high (0.8) | Оба теста явно проверяют работу **параметризованных URI**: получение динамического ресурса с параметрами и с несколькими path-параметрами (“parameterized input”, “multiple path parameters”). Не до конца видно, проверяется ли именно **“определять/объявлять templates”** (как создаются/регистрируются шаблоны), но поведенчески способность обрабатывать параметризованные URI подтверждается. |
| req_006: Progress notifications — «Система должна отправлять уведомления о прогрессе выполнения долгих операций (progress notifications).» | none | — | high (0.85) | В предоставленном наборе тестов нет явных проверок отправки progress notifications (ни событий прогресса, ни формата уведомлений, ни длительных операций). |
| req_008: Конфигурация через McpModule.forRoot — «…через `McpModule.forRoot()` с указанием имени сервера и версии.» | none | — | high (0.8) | В “nearTests” нет тестов, которые явно проверяют, что конфигурация производится через `McpModule.forRoot()` и что **обязательны/используются** имя сервера и версия. В “suitsWithTests” присутствуют только id без привязанных тестов (`tests: []`), что не даёт доказательств покрытия. |
| req_002: Streamable HTTP transport — «…поддерживать транспорт Streamable HTTP для выполнения команд и получения потокового отклика.» | partial | test-uuid3: Customize HTTP response streaming behavior (custom-decorator.spec.ts:23–29); test-uuid4: Maintain default HTTP response streaming behavior (custom-decorator.spec.ts:31–34) | medium (0.65) | Эти тесты явно про **streaming behavior HTTP-ответа** (кастомизация/дефолтное поведение). Однако в требовании есть ещё минимум две бизнес-части: **(1) поддержка именно Streamable HTTP transport** как транспорта MCP и **(2) выполнение команд** через него. В предоставленных формулировках тестов нет прямой проверки “command execution over Streamable HTTP transport”, поэтому покрытие только частичное. |
| req_005: Валидация Zod — «Валидация параметров вызова инструментов должна выполняться с помощью Zod.» | none | — | high (0.85) | Нет тестов, которые явно проверяют использование Zod (например, что при невалидном payload возвращается ошибка валидации, и/или что схема — Zod, а не другая библиотека). |

---

## **Risk & Robustness Narrative**

### Ключевые риски
- **Непокрытые требования (none)**: req_015, req_013, req_011, req_004, req_006, req_008, req_005 — это большая доля требований без явной тестовой валидации.
- **Частичное/поверхностное покрытие**:
    - req_014 (“безопасным”) покрыто только проверкой отказа при неверных креденшалах; безопасность шире.
    - req_002 частично покрыто “streaming behavior”, но не доказана поддержка *Streamable HTTP transport* и выполнение команд через него.
- **Ложные срабатывания из-за семантической схожести (vector bias)**:
    - req_013 “эффективность”: nearTests имеют score, но отсутствует текстовое доказательство (mainIntent `"."`), поэтому связь может быть полностью ложной.
    - req_004: тесты про “list tools/resources” семантически близки к “register”, но не проверяют “авто‑обнаружение по декораторам”.
- **Смещение на детали реализации вместо бизнес-намерения**:
    - Для req_005 важно не просто “валидация”, а именно “валидация вызова инструмента” и “используя Zod”. Без явных утверждений тест может проверять поведение, но не гарантию выбора технологии (или наоборот).

### Измерение качества результата (true vs false coverage)
Сигналы **истинного покрытия**:
- В описании/фрагментах теста прямо присутствуют ключевые термины/критерии требования (например, “parameterized URI/template”, “reject unauthorized access”, “streaming response”, “McpModule.forRoot name/version”).
- Тест проверяет наблюдаемый бизнес-результат (вход → ожидаемый выход/событие), а не только косвенное поведение.

Сигналы **ложного покрытия**:
- Связь держится только на similarity score без явного утверждения в тексте теста.
- Тест проверяет соседнюю функциональность (например, “list tools”) но не проверяет заявленный механизм (“auto-discovery via decorators”).

Оценка **confidence**:
- Высокая, когда есть явное совпадение формулировки и проверяемого результата (req_009).
- Средняя/низкая, когда тесты есть, но покрывают только часть смысла или формулировки теста не доказывают бизнес-намерение (req_002, req_014).

### Улучшение устойчивости (robustness)
- **Уточнить требования с критериями приемки**:
    - req_013: определить метрики (p95 latency, throughput, CPU/RAM, max concurrent connections) и пороги.
    - req_014: перечислить обязательные меры (authn/authz, TLS, rate limiting, audit, threat model).
    - req_015: указать CRM, объекты интеграции, протоколы, направления синхронизации, ошибки/ретраи.
- **Структурировать тесты под бизнес-намерение**:
    - req_004: тест “Given класс с @Tool/@Resource/@Prompt → When стартуем MCP‑Nest → Then в /tools,/resources,/prompts присутствуют элементы” (и отрицательный тест без декоратора).
    - req_008: тест “McpModule.forRoot({name, version}) → сервер отдаёт метаданные name/version”.
    - req_005: тесты на невалидные параметры tool call с проверкой конкретной сигнатуры/ошибки валидации (и при необходимости — проверка, что используются Zod-схемы).
- **Не полагаться на similarity как на доказательство**: использовать similarity только для “подсветки кандидатов”, а покрытие подтверждать ссылкой на assert/expect/проверяемый эффект.

---

## **Summary**
- **Общий уровень покрытия**: низкий — из 10 требований только 1 имеет хорошее покрытие (req_009), 2 частичное (req_014, req_002), остальные не имеют подтверждённого покрытия.
- **Основные пробелы**: CRM‑интеграция, React UI, progress notifications, конфигурация через `McpModule.forRoot`, Zod‑валидация, авто‑обнаружение/регистрация по декораторам.
- **Частые причины слабого покрытия**:
    - требования слишком общие/некачественные (req_013/014/015);
    - тесты проверяют близкую функциональность, но не ключевой механизм/намерение (req_004, req_002);
    - отсутствие явных тестов под конкретное требование.
- **Действия**: (1) уточнить критерии приемки для некачественных требований, (2) добавить целевые e2e/интеграционные тесты под req_004/005/006/008/011/015, (3) в тестах фиксировать проверяемый бизнес-результат и явно привязывать его к требованию.
