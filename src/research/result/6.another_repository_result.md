

**Coverage Report Table**

| Requirement | Coverage score | Linked tests | Confidence score | Evidence |
|-------------|---------------|--------------|------------------|----------|
| FR-001: Rule Parsing – The system must accept a JsonLogic rule represented as a JSON object and successfully parse it for evaluation. | none | - | low | No tests explicitly verify JSON parsing. Tests listed (e.g., array access during evaluation) focus on evaluation phase, not parsing. Parsing requires validation of JSON structure conversion, which is not tested. |
| FR-007: Always/Never Behavior – When the first argument passed to the evaluator is a non-object and non-associative array (e.g., true/false), the system must return it directly. | none | - | low | Tests reference array access on PHP objects (e.g., "returns default value for undefined array access"), but none validate returning non-object values (e.g., booleans) directly. Requirement intent is unverified. |
| FR-001: Rule Parsing – The system must accept a JsonLogic rule represented as a JSON object and successfully parse it for evaluation. | none | - | low | No tests explicitly verify JSON parsing. Tests listed (e.g., array access during evaluation) focus on evaluation phase, not parsing. Parsing requires validation of JSON structure conversion, which is not tested. |
| FR-002: Logical Evaluation Core – The system must evaluate JsonLogic rules using supported operators (e.g., ==, >, and, or, var). | partial | /tests/ObjectWithArrayAccessorsTest.php: handles array access on PHP objects implementing ArrayAccess interface<br>/tests/ObjectWithArrayAccessorsTest.php: handles mixed property and array access | medium | Tests explicitly cover `var` operator via array access, but no tests validate other operators (e.g., `==`, `>`, `and`, `or`). Coverage is limited to one operator type. |
| FR-002: Logical Evaluation Core – The system must evaluate JsonLogic rules using supported operators (e.g., ==, >, and, or, var). | partial | /tests/ObjectWithArrayAccessorsTest.php: handles array access on PHP objects implementing ArrayAccess interface<br>/tests/ObjectWithArrayAccessorsTest.php: handles mixed property and array access | medium | Tests explicitly cover `var` operator via array access, but no tests validate other operators (e.g., `==`, `>`, `and`, `or`). Coverage is limited to one operator type. |
| FR-003: Data-Driven Rule Execution – The system must allow applying a rule against a given data set, returning correct results based on data values. | none | - | low | No tests listed in nearTests for this requirement. Requirement intent (applying rules to data and validating results) is unverified. |
| FR-003: Data-Driven Rule Execution – The system must allow applying a rule against a given data set, returning correct results based on data values. | none | - | low | No tests listed in nearTests for this requirement. Requirement intent (applying rules to data and validating results) is unverified. |
| FR-004: Support for Variable Access – The system must support the var operator to extract values from input data using keys and numeric indices. | none | - | low | No tests listed in nearTests for this requirement. Requirement intent (variable extraction via keys/indices) is unverified. |
| FR-004: Support for Variable Access – The system must support the var operator to extract values from input data using keys and numeric indices. | none | - | low | No tests listed in nearTests for this requirement. Requirement intent (variable extraction via keys/indices) is unverified. |
| FR-005: Support for Nested Rules – The library must allow rules to be nested (compound logic) and evaluate them correctly. | none | - | low | No tests listed in nearTests for this requirement. Requirement intent (nested rule evaluation) is unverified. |
| FR-005: Support for Nested Rules – The library must allow rules to be nested (compound logic) and evaluate them correctly. | none | - | low | No tests listed in nearTests for this requirement. Requirement intent (nested rule evaluation) is unverified. |
| FR-006: Syntax Flexibility – The system must accept JsonLogic expressions as both associative arrays and objects in PHP. | good | /tests/ObjectWithArrayAccessorsTest.php: handles array access on PHP objects implementing ArrayAccess interface<br>/tests/ObjectWithArrayAccessorsTest.php: handles mixed property and array access<br>/tests/MagicPropertiesTest.php: returns magic value for defined property<br>/tests/MagicPropertiesTest.php: returns default value for method access<br>/tests/MagicPropertiesTest.php: handles undefined magic properties | high | Tests explicitly validate handling of array syntax and property access on PHP objects (e.g., ArrayAccess interface, magic methods). This directly verifies acceptance of expressions as both associative arrays and objects. |
| FR-006: Syntax Flexibility – The system must accept JsonLogic expressions as both associative arrays and objects in PHP. | good | /tests/ObjectWithArrayAccessorsTest.php: handles array access on PHP objects implementing ArrayAccess interface<br>/tests/ObjectWithArrayAccessorsTest.php: handles mixed property and array access<br>/tests/MagicPropertiesTest.php: returns magic value for defined property<br>/tests/MagicPropertiesTest.php: returns default value for method access<br>/tests/MagicPropertiesTest.php: handles undefined magic properties | high | Tests explicitly validate handling of array syntax and property access on PHP objects (e.g., ArrayAccess interface, magic methods). This directly verifies acceptance of expressions as both associative arrays and objects. |
| FR-007: Always/Never Behavior – When the first argument passed to the evaluator is a non-object and non-associative array (e.g., true/false), the system must return it directly. | none | - | low | Tests reference array access on PHP objects (e.g., "returns default value for undefined array access"), but none validate returning non-object values (e.g., booleans) directly. Requirement intent is unverified. |
| FR-008: PHP Compatibility – The library must be installable via Composer and work with supported PHP versions (>=7.2.0). | none | - | low | No tests listed in nearTests for this requirement. Requirement intent (Composer installation and PHP version compatibility) is unverified. |
| FR-008: PHP Compatibility – The library must be installable via Composer and work with supported PHP versions (>=7.2.0). | none | - | low | No tests listed in nearTests for this requirement. Requirement intent (Composer installation and PHP version compatibility) is unverified. |
| FR-009: Error Handling – The system must handle incorrectly formed JsonLogic rules gracefully with informative error responses/messages. | good | /tests/ObjectWithArrayAccessorsTest.php: returns default value for undefined array access<br>/tests/MagicPropertiesTest.php: returns default value for method access<br>/tests/MagicPropertiesTest.php: handles undefined magic properties | high | Tests explicitly return default values for undefined array/method accesses, directly validating graceful error handling for incorrect rule structures. |
| FR-009: Error Handling – The system must handle incorrectly formed JsonLogic rules gracefully with informative error responses/messages. | good | /tests/ObjectWithArrayAccessorsTest.php: returns default value for undefined array access<br>/tests/MagicPropertiesTest.php: returns default value for method access<br>/tests/MagicPropertiesTest.php: handles undefined magic properties | high | Tests explicitly return default values for undefined array/method accesses, directly validating graceful error handling for incorrect rule structures. |
| FR-010: Test Suite Coverage – There must be a test suite verifying correct evaluation of rules across a range of conditions and operators. | good | /tests/ObjectWithArrayAccessorsTest.php (multiple tests)<br>/tests/MagicPropertiesTest.php (multiple tests) | medium | Test suite exists with tests covering array access, property access, and error handling. However, coverage of all operators (e.g., `==`, `>`, `and`, `or`) and edge cases is not fully verified. |
| FR-010: Test Suite Coverage – There must be a test suite verifying correct evaluation of rules across a range of conditions and operators. | good | /tests/ObjectWithArrayAccessorsTest.php (multiple tests)<br>/tests/MagicPropertiesTest.php (multiple tests) | medium | Test suite exists with tests covering array access, property access, and error handling. However, coverage of all operators (e.g., `==`, `>`, `and`, `or`) and edge cases is not fully verified. |

**Risk & Robustness**

- *Key risks*:
    - **Uncovered requirements**: Critical gaps exist for parsing (FR-001), data-driven execution (FR-003), variable access (FR-004), nested rules (FR-005), always/never behavior (FR-007), and PHP compatibility (FR-008). These have no direct test evidence.
    - **Partial coverage**: FR-002 (logical evaluation) only validates the `var` operator via array access, but lacks tests for other operators (e.g., `==`, `>`, `and`, `or`).
    - **False positives**: Semantic similarity scores (e.g., high scores for FR-001 tests) mislead coverage assessment. Tests for array access during evaluation are tangentially related but do not verify parsing.
    - **Implementation focus**: Tests emphasize evaluation details (e.g., array access) rather than core business intents (e.g., parsing JSON structure or handling booleans directly).

- *Measuring result quality*:
    - **True coverage** requires tests that explicitly validate requirement-specific actions (e.g., a parsing test must check JSON-to-structure conversion, not evaluation results).
    - **False coverage** occurs when tests only share thematic keywords (e.g., "array access" for "parsing") but lack direct validation of the requirement’s intent.
    - Confidence is high only when tests mirror requirement language (e.g., "returns default value for undefined access" for error handling). Low confidence arises when tests are ambiguous or tangential.

- *Improving robustness*:
    - **Clarify requirements**: Define explicit acceptance criteria (e.g., "parsing must validate JSON syntax and convert to internal structure without evaluation").
    - **Structure tests for clarity**: Write tests with descriptive names and fragments that directly reference requirement intent (e.g., "Test parsing of JSON rule with valid syntax").
    - **Validate beyond semantics**: Require test descriptions to include concrete validation steps (e.g., "assert parsed structure matches expected object") rather than relying on keyword matching.
    - **Decompose complex requirements**: Split requirements like "logical evaluation" into sub-requirements per operator (e.g., "test equality operator `==`") to ensure granular coverage.

**Summary**
- Overall coverage is **low**, with 12 of 16 requirements having no direct test evidence. Critical gaps exist in parsing, data-driven execution, variable access, nested rules, and PHP compatibility.
- Major issues stem from tests focusing on evaluation details (e.g., array access) rather than core business intents (e.g., parsing JSON or handling booleans), and semantic similarity scores creating false confidence.
- Key causes: ambiguous test descriptions, lack of requirement-specific validation steps, and overreliance on keyword matching instead of explicit evidence.
- **Actionable recommendations**:
    1. Create dedicated tests for uncovered requirements (e.g., a parsing test that validates JSON structure conversion).
    2. Refine requirement acceptance criteria to include concrete validation steps (e.g., "for FR-007, test returning `true` when first argument is boolean").
    3. Remove semantic similarity scores from coverage decisions; require direct evidence in test descriptions.
    4. Decompose broad requirements (e.g., "logical evaluation") into operator-specific sub-requirements to ensure comprehensive testing.
